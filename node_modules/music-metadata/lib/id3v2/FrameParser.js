"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Util_1 = require("../common/Util");
var Token = require("token-types");
var ID3v2_1 = require("./ID3v2");
var _debug = require("debug");
var debug = _debug("music-metadata:id3v2:frame-parser");
var FrameParser = /** @class */ (function () {
    function FrameParser() {
    }
    FrameParser.readData = function (b, type, major, includeCovers) {
        var encoding = FrameParser.getTextEncoding(b[0]);
        var length = b.length;
        var offset = 0;
        var output = []; // ToDo
        var nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);
        var fzero;
        var out = {};
        switch (type !== 'TXXX' && type[0] === 'T' ? 'T*' : type) {
            case 'T*': // 4.2.1. Text information frames - details
            case 'IPLS': // v2.3: Involved people list
                var text = Util_1.default.decodeString(b.slice(1), encoding).replace(/\x00+$/, '');
                switch (type) {
                    case 'TMCL': // Musician credits list
                    case 'TIPL': // Involved people list
                    case 'IPLS': // Involved people list
                        output = FrameParser.splitValue(4, text);
                        output = FrameParser.functionList(output);
                        break;
                    case 'TRK':
                    case 'TRCK':
                    case 'TPOS':
                        output = text;
                        break;
                    case 'TCOM':
                    case 'TEXT':
                    case 'TOLY':
                    case 'TOPE':
                    case 'TPE1':
                    case 'TSRC':
                        // id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
                        output = FrameParser.splitValue(major, text);
                        break;
                    default:
                        output = major >= 4 ? FrameParser.splitValue(major, text) : [text];
                }
                break;
            case 'TXXX':
                output = FrameParser.readIdentifierAndData(b, offset + 1, length, encoding);
                output = {
                    description: output.id,
                    text: FrameParser.splitValue(major, Util_1.default.decodeString(output.data, encoding).replace(/\x00+$/, ''))
                };
                break;
            case 'PIC':
            case 'APIC':
                if (includeCovers) {
                    var pic = {};
                    offset += 1;
                    switch (major) {
                        case 2:
                            pic.format = Util_1.default.decodeString(b.slice(offset, offset + 3), encoding);
                            offset += 3;
                            break;
                        case 3:
                        case 4:
                            var enc = 'iso-8859-1';
                            fzero = Util_1.default.findZero(b, offset, length, enc);
                            pic.format = Util_1.default.decodeString(b.slice(offset, fzero), enc);
                            offset = fzero + 1;
                            break;
                        default:
                            throw new Error('Warning: unexpected major versionIndex: ' + major);
                    }
                    pic.format = FrameParser.fixPictureMimeType(pic.format);
                    pic.type = ID3v2_1.AttachedPictureType[b[offset]];
                    offset += 1;
                    fzero = Util_1.default.findZero(b, offset, length, encoding);
                    pic.description = Util_1.default.decodeString(b.slice(offset, fzero), encoding);
                    offset = fzero + nullTerminatorLength;
                    pic.data = Buffer.from(b.slice(offset, length));
                    output = pic;
                }
                break;
            case 'CNT':
            case 'PCNT':
                output = Token.UINT32_BE.get(b, 0);
                break;
            case 'SYLT':
                // skip text encoding (1 byte),
                //      language (3 bytes),
                //      time stamp format (1 byte),
                //      content tagTypes (1 byte),
                //      content descriptor (1 byte)
                offset += 7;
                output = [];
                while (offset < length) {
                    var txt = b.slice(offset, offset = Util_1.default.findZero(b, offset, length, encoding));
                    offset += 5; // push offset forward one +  4 byte timestamp
                    output.push(Util_1.default.decodeString(txt, encoding));
                }
                break;
            case 'ULT':
            case 'USLT':
            case 'COM':
            case 'COMM':
                offset += 1;
                out.language = Util_1.default.decodeString(b.slice(offset, offset + 3), 'iso-8859-1');
                offset += 3;
                fzero = Util_1.default.findZero(b, offset, length, encoding);
                out.description = Util_1.default.decodeString(b.slice(offset, fzero), encoding);
                offset = fzero + nullTerminatorLength;
                out.text = Util_1.default.decodeString(b.slice(offset, length), encoding).replace(/\x00+$/, '');
                output = [out];
                break;
            case 'UFID':
                output = FrameParser.readIdentifierAndData(b, offset, length, 'iso-8859-1');
                output = { owner_identifier: output.id, identifier: output.data };
                break;
            case 'PRIV': // private frame
                output = FrameParser.readIdentifierAndData(b, offset, length, 'iso-8859-1');
                output = { owner_identifier: output.id, data: output.data };
                break;
            case 'POPM': // Popularimeter
                fzero = Util_1.default.findZero(b, offset, length, encoding);
                var email = Util_1.default.decodeString(b.slice(offset, fzero), encoding);
                offset = fzero + FrameParser.getNullTerminatorLength(encoding);
                var dataLen = length - offset;
                output = {
                    email: email,
                    rating: b.readUInt8(offset),
                    counter: dataLen >= 5 ? b.readUInt32BE(offset + 1) : undefined
                };
                break;
            case 'GEOB': { // General encapsulated object
                fzero = Util_1.default.findZero(b, offset + 1, length, encoding);
                var mimeType = Util_1.default.decodeString(b.slice(offset + 1, fzero), 'iso-8859-1');
                offset = fzero + 1;
                fzero = Util_1.default.findZero(b, offset, length - offset, encoding);
                var filename = Util_1.default.decodeString(b.slice(offset + 1, fzero), 'iso-8859-1');
                offset = fzero + 1;
                fzero = Util_1.default.findZero(b, offset, length - offset, encoding);
                var description = Util_1.default.decodeString(b.slice(offset + 1, fzero), 'iso-8859-1');
                output = {
                    type: mimeType,
                    filename: filename,
                    description: description,
                    data: b.slice(offset + 1, length)
                };
                break;
            }
            // W-Frames:
            case 'WCOM':
            case 'WCOP':
            case 'WOAF':
            case 'WOAR':
            case 'WOAS':
            case 'WORS':
            case 'WPAY':
            case 'WPUB':
                // Decode URL
                output = Util_1.default.decodeString(b.slice(offset, fzero), encoding);
                break;
            case 'WXXX': {
                // Decode URL
                fzero = Util_1.default.findZero(b, offset + 1, length, encoding);
                var description = Util_1.default.decodeString(b.slice(offset + 1, fzero), 'iso-8859-1');
                offset = fzero + 1;
                fzero = Util_1.default.findZero(b, offset, length - offset, encoding);
                output = { description: description, url: Util_1.default.decodeString(b.slice(offset, length - offset), encoding) };
                break;
            }
            case 'MCDI': {
                // Music CD identifier
                output = b.slice(0, length);
                break;
            }
            default:
                debug('Warning: unsupported id3v2-tag-type: ' + type);
                break;
        }
        return output;
    };
    FrameParser.fixPictureMimeType = function (pictureType) {
        pictureType = pictureType.toLocaleLowerCase();
        switch (pictureType) {
            case 'jpg':
                return 'image/jpeg';
            case 'png':
                return 'image/png';
        }
        return pictureType;
    };
    /**
     * Converts TMCL (Musician credits list) or TIPL (Involved people list)
     * @param entries
     */
    FrameParser.functionList = function (entries) {
        var res = {};
        for (var i = 0; i + 1 < entries.length; i += 2) {
            var names = entries[i + 1].split(',');
            res[entries[i]] = res.hasOwnProperty(entries[i]) ? res[entries[i]].concat(names) : names;
        }
        return res;
    };
    /**
     * id3v2.4 defines that multiple T* values are separated by 0x00
     * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
     * @param {number} major Major version, e.g. (4) for  id3v2.4
     * @param {string} text Concatenated tag value
     * @returns {string[]} Slitted value
     */
    FrameParser.splitValue = function (major, text) {
        var values = text.split(major >= 4 ? /\x00/g : /\//g);
        return FrameParser.trimArray(values);
    };
    FrameParser.trimArray = function (values) {
        for (var i = 0; i < values.length; ++i) {
            values[i] = values[i].replace(/\x00+$/, '').trim();
        }
        return values;
    };
    FrameParser.readIdentifierAndData = function (b, offset, length, encoding) {
        var fzero = Util_1.default.findZero(b, offset, length, encoding);
        var id = Util_1.default.decodeString(b.slice(offset, fzero), encoding);
        offset = fzero + FrameParser.getNullTerminatorLength(encoding);
        return { id: id, data: b.slice(offset, length) };
    };
    FrameParser.getTextEncoding = function (byte) {
        switch (byte) {
            case 0x00:
                return 'iso-8859-1'; // binary
            case 0x01:
            case 0x02:
                return 'utf16'; // 01 = with bom, 02 = without bom
            case 0x03:
                return 'utf8';
            default:
                return 'utf8';
        }
    };
    FrameParser.getNullTerminatorLength = function (enc) {
        switch (enc) {
            case 'utf16':
                return 2;
            default:
                return 1;
        }
    };
    return FrameParser;
}());
exports.default = FrameParser;
