"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Token = require("token-types");
var Atom = require("./Atom");
var ID3v1Parser_1 = require("../id3v1/ID3v1Parser");
var Util_1 = require("../common/Util");
var _debug = require("debug");
var debug = _debug("music-metadata:parser:MP4");
/*
 * Parser for: MPEG-4 Audio / MPEG-4 Part 3 (m4a/mp4) extension
 * Support for Apple iTunes MP4 tags as found in a M4A/MP4 file
 * Ref:
 *   http://developer.apple.com/mac/library/documentation/QuickTime/QTFF/Metadata/Metadata.html
 *   http://atomicparsley.sourceforge.net/mpeg-4files.html
 */
var MP4Parser = /** @class */ (function () {
    function MP4Parser() {
        this.metaAtomsTotalLength = 0;
        this.format = {
            dataformat: 'MPEG-4 audio'
        };
        this.tags = [];
        this.warnings = []; // ToDo: make this part of the parsing result
    }
    MP4Parser.read_BE_Signed_Integer = function (value) {
        return Util_1.default.readIntBE(value, 0, value.length);
    };
    MP4Parser.read_BE_Unsigned_Integer = function (value) {
        return Util_1.default.readUIntBE(value, 0, value.length);
    };
    MP4Parser.prototype.parse = function (tokenizer, options) {
        var _this = this;
        this.tokenizer = tokenizer;
        this.options = options;
        return this.parseAtom([], this.tokenizer.fileSize).then(function () {
            return {
                format: _this.format,
                native: {
                    "iTunes MP4": _this.tags
                }
            };
        });
    };
    MP4Parser.prototype.parseAtom = function (parent, size) {
        var _this = this;
        // Parse atom header
        return this.tokenizer.readToken(Atom.Atom.Header)
            .then(function (header) {
            debug("parse atom name=%s, len=%s on offset=%s", parent.concat([header.name]).join('/'), header.length, _this.tokenizer.position); //  buf.toString('ascii')
            return _this.parseAtomData(header, parent).then(function () {
                size -= header.length;
                if (size > 0) {
                    return _this.parseAtom(parent, size);
                }
            });
        });
    };
    MP4Parser.prototype.parseAtomData = function (header, parent) {
        var _this = this;
        var dataLen = header.length - 8;
        switch (header.name) {
            case "ftyp":
                return this.parseAtom_ftyp(dataLen).then(function () { return null; });
            // "Container" atoms, contain nested atoms: 'moov', 'udta', 'meta', 'ilst', 'trak', 'mdia'
            case "moov": // The Movie Atom: contains other atoms
            case "udta": // User defined atom
            case "trak":
            case "mdia": // Media atom
            case "minf": // Media Information Atom
            case "stbl": // Media Information Atom
                return this.parseAtom(parent.concat([header.name]), dataLen);
            case "meta": // Metadata Atom, ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
                return this.tokenizer.readToken(new Token.IgnoreType(4))
                    .then(function () {
                    return _this.parseMetaAtom(parent.concat([header.name]), dataLen - 4);
                }); // meta has 4 bytes of padding, ignore
            case "mdhd": // Media header atom
                return this.parseAtom_mdhd(dataLen);
            case "mvhd": // 'movie' => 'mvhd': movie header atom; child of Movie Atom
                return this.parseAtom_mvhd(dataLen);
            case "tkhd":
                return this.tokenizer.readToken(new Atom.TrackHeaderAtom(dataLen))
                    .then(function (tkhd) {
                    debug("Ignore: name=%s, len=%s", parent.concat([header.name]).join('/'), header.length); //  buf.toString('ascii')
                });
            default:
                return this.tokenizer.readToken(new Token.BufferType(dataLen))
                    .then(function (buf) {
                    debug("Ignore: name=%s, len=%s", parent.concat([header.name]).join('/'), header.length); //  buf.toString('ascii')
                });
        }
    };
    /**
     * Parse Metadata Atom (meta), ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
     * @param {string[]} parent Parent Atoms
     * @param {number} size Remaining meta atom size
     * @returns {Promise<void>}
     */
    MP4Parser.prototype.parseMetaAtom = function (parent, size) {
        var _this = this;
        // Parse atom header
        return this.tokenizer.readToken(Atom.Atom.Header)
            .then(function (header) {
            debug("parse atom name=%s, len=%s on offset=%s", parent.concat([header.name]).join('/'), header.length, _this.tokenizer.position); //  buf.toString('ascii')
            return _this.parseMetaAtomData(header, parent).then(function () {
                size -= header.length;
                if (size > 0) {
                    return _this.parseMetaAtom(parent, size);
                }
            });
        });
    };
    MP4Parser.prototype.parseMetaAtomData = function (header, parent) {
        var dataLen = header.length - 8;
        switch (header.name) {
            case "ilst": // 'meta' => 'ilst': Metadata Item List Atom
            case "<id>": // 'meta' => 'ilst' => '<id>': metadata item atom
                // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW24
                return this.parseMetadataItemList(dataLen);
            default: // If the Atom explicitly ignored, and not a meta-data-item-data, it will likely cause a crash
                return this.parseMetadataItemData(header.name, dataLen);
            case "free":
            case "hdlr": // Handler Reference Atoms, https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-BBCIBHFD
                return this.tokenizer.readToken(new Token.BufferType(dataLen))
                    .then(function (buf) {
                    debug("Ignore: name=%s, len=%s", parent.concat([header.name]).join('/'), header.length); //  buf.toString('ascii')
                });
        }
    };
    MP4Parser.prototype.parseAtom_ftyp = function (len) {
        var _this = this;
        return this.tokenizer.readToken(Atom.Atom.ftyp).then(function (ftype) {
            len -= Atom.Atom.ftyp.len;
            if (len > 0) {
                return _this.parseAtom_ftyp(len).then(function (types) {
                    types.push(ftype.type);
                    return types;
                });
            }
            return [];
        });
    };
    /**
     * Parse movie header (mvhd) atom
     * @param len
     */
    MP4Parser.prototype.parseAtom_mvhd = function (len) {
        var _this = this;
        return this.tokenizer.readToken(Atom.Atom.mvhd).then(function (mvhd) {
            _this.parse_mxhd(mvhd);
        });
    };
    /**
     * Parse media header (mdhd) atom
     * @param len
     */
    MP4Parser.prototype.parseAtom_mdhd = function (len) {
        var _this = this;
        return this.tokenizer.readToken(Atom.Atom.mdhd).then(function (mdhd) {
            _this.parse_mxhd(mdhd);
        });
    };
    MP4Parser.prototype.parse_mxhd = function (mxhd) {
        this.format.sampleRate = mxhd.timeScale;
        this.format.duration = mxhd.duration / mxhd.timeScale; // calculate duration in seconds
    };
    /**
     * Parse Meta-item-list-atom (item of 'ilst' atom)
     * @param len
     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
     */
    MP4Parser.prototype.parseMetadataItemList = function (len) {
        var _this = this;
        // Parse atom header
        return this.tokenizer.readToken(Atom.Atom.Header).then(function (header) {
            debug("metadata-item: name=%s, len=%s", header.name, header.length);
            return _this.parseMetadataItemData(header.name, header.length - Atom.Atom.Header.len).then(function () {
                var remaining = len - Atom.Atom.Header.len - header.length;
                if (remaining > 0) {
                    return _this.parseMetadataItemList(remaining);
                }
                else
                    return;
            });
        });
    };
    MP4Parser.prototype.parseMetadataItemData = function (tagKey, remLen) {
        var _this = this;
        // Parse Meta Item List Atom
        return this.tokenizer.readToken(Atom.Atom.Header).then(function (header) {
            var dataLen = header.length - Atom.Atom.Header.len;
            switch (header.name) {
                case "data": // value atom
                    return _this.parseValueAtom(tagKey, header);
                case "name": // name atom (optional)
                    return _this.tokenizer.readToken(new Atom.NameAtom(dataLen)).then(function (name) {
                        tagKey += ":" + name.name;
                        return header.length;
                    });
                case "mean": // name atom (optional)
                    return _this.tokenizer.readToken(new Atom.NameAtom(dataLen)).then(function (mean) {
                        // console.log("  %s[%s] = %s", tagKey, header.name, mean.name);
                        tagKey += ":" + mean.name;
                        return header.length;
                    });
                default:
                    return _this.tokenizer.readToken(new Token.BufferType(dataLen)).then(function (dataAtom) {
                        debug("Unsupported meta-item: %s[%s] => value=%s ascii=%s", tagKey, header.name, dataAtom.toString("hex"), dataAtom.toString("ascii"));
                        _this.warnings.push("unsupported meta-item: " + tagKey + "[" + header.name + "] => value=" + dataAtom.toString("hex") + " ascii=" + dataAtom.toString("ascii"));
                        return header.length;
                    });
            }
        }).then(function (len) {
            var remaining = remLen - len;
            if (remaining === 0) {
                return;
            }
            else {
                return _this.parseMetadataItemData(tagKey, remaining);
            }
        });
    };
    MP4Parser.prototype.parseValueAtom = function (tagKey, header) {
        var _this = this;
        return this.tokenizer.readToken(new Atom.DataAtom(header.length - Atom.Atom.Header.len)).then(function (dataAtom) {
            if (dataAtom.type.set !== 0) {
                throw new Error("Unsupported type-set != 0: " + dataAtom.type.set);
            }
            // Use well-known-type table
            // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35
            switch (dataAtom.type.type) { // ToDo?: use enum
                case 0: // reserved: Reserved for use where no type needs to be indicated
                    switch (tagKey) {
                        case "trkn":
                        case "disk":
                            var num = Token.UINT8.get(dataAtom.value, 3);
                            var of = Token.UINT8.get(dataAtom.value, 5);
                            // console.log("  %s[data] = %s/%s", tagKey, num, of);
                            _this.tags.push({ id: tagKey, value: num + "/" + of });
                            break;
                        case "gnre":
                            var genreInt = Token.UINT8.get(dataAtom.value, 1);
                            var genreStr = ID3v1Parser_1.Genres[genreInt - 1];
                            // console.log("  %s[data] = %s", tagKey, genreStr);
                            _this.tags.push({ id: tagKey, value: genreStr });
                            break;
                        default:
                        // console.log("  reserved-data: name=%s, len=%s, set=%s, type=%s, locale=%s, value{ hex=%s, ascii=%s }",
                        // header.name, header.length, dataAtom.type.set, dataAtom.type.type, dataAtom.locale, dataAtom.value.toString('hex'), dataAtom.value.toString('ascii'));
                    }
                    break;
                case 1: // UTF-8: Without any count or NULL terminator
                    _this.tags.push({ id: tagKey, value: dataAtom.value.toString("utf-8") });
                    break;
                case 13: // JPEG
                    if (_this.options.skipCovers)
                        break;
                    _this.tags.push({
                        id: tagKey, value: {
                            format: "image/jpeg",
                            data: Buffer.from(dataAtom.value)
                        }
                    });
                    break;
                case 14: // PNG
                    if (_this.options.skipCovers)
                        break;
                    _this.tags.push({
                        id: tagKey, value: {
                            format: "image/png",
                            data: Buffer.from(dataAtom.value)
                        }
                    });
                    break;
                case 21: // BE Signed Integer
                    _this.tags.push({ id: tagKey, value: MP4Parser.read_BE_Signed_Integer(dataAtom.value) });
                    break;
                case 22: // BE Unsigned Integer
                    _this.tags.push({ id: tagKey, value: MP4Parser.read_BE_Unsigned_Integer(dataAtom.value) });
                    break;
                case 65: // An 8-bit signed integer
                    _this.tags.push({ id: tagKey, value: dataAtom.value.readInt8(0) });
                    break;
                case 66: // A big-endian 16-bit signed integer
                    _this.tags.push({ id: tagKey, value: dataAtom.value.readInt16BE(0) });
                    break;
                case 67: // A big-endian 32-bit signed integer
                    _this.tags.push({ id: tagKey, value: dataAtom.value.readInt32BE(0) });
                    break;
                default:
                    throw new Error("Unsupported well-known-type: " + dataAtom.type.type);
            }
            return header.length;
        });
    };
    return MP4Parser;
}());
exports.MP4Parser = MP4Parser;
