/// <reference types="node" />
import { INativeAudioMetadata, IOptions } from "./";
import * as strtok3 from "strtok3";
import { Promise } from "es6-promise";
import * as Stream from "stream";
export interface ITokenParser {
    parse(tokenizer: strtok3.ITokenizer, options: IOptions): Promise<INativeAudioMetadata>;
}
export declare class ParserFactory {
    /**
     * Extract metadata from the given audio file
     * @param filePath File path of the audio file to parse
     * @param opts
     *   .fileSize=true  Return filesize
     *   .native=true    Will return original header in result
     * @returns {Promise<INativeAudioMetadata>}
     */
    static parseFile(filePath: string, opts?: IOptions): Promise<INativeAudioMetadata>;
    /**
     * Parse metadata from stream
     * @param stream Node stream
     * @param mimeType The mime-type, e.g. "audio/mpeg", extension e.g. ".mp3" or filename. This is used to redirect to the correct parser.
     * @param opts Parsing options
     * @returns {Promise<INativeAudioMetadata>}
     */
    static parseStream(stream: Stream.Readable, mimeType: string, opts?: IOptions): Promise<INativeAudioMetadata>;
    /**
     *  Parse metadata from tokenizer
     * @param {ITokenizer} tokenizer
     * @param {string} contentType
     * @param {IOptions} opts
     * @returns {Promise<INativeAudioMetadata>}
     */
    static parse(tokenizer: strtok3.ITokenizer, contentType: string, opts?: IOptions): Promise<INativeAudioMetadata>;
    /**
     * @param filePath Path, filename or extension to audio file
     * @return ITokenParser if extension is supported; otherwise false
     */
    private static getParserForExtension;
    /**
     * @param {string} mimeType MIME-Type, extension, path or filename
     * @returns ITokenParser if MIME-type is supported; otherwise false
     */
    private static getParserForMimeType;
    private warning;
}
