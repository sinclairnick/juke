"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Util_1 = require("../common/Util");
var Token = require("token-types");
var FourCC_1 = require("../common/FourCC");
var FileType = require("file-type");
var _debug = require("debug");
var debug = _debug("music-metadata:parser:APEv2");
var DataType;
(function (DataType) {
    DataType[DataType["text_utf8"] = 0] = "text_utf8";
    DataType[DataType["binary"] = 1] = "binary";
    DataType[DataType["external_info"] = 2] = "external_info";
    DataType[DataType["reserved"] = 3] = "reserved";
})(DataType || (DataType = {}));
var Structure = /** @class */ (function () {
    function Structure() {
    }
    Structure.parseTagFlags = function (flags) {
        return {
            containsHeader: Structure.isBitSet(flags, 31),
            containsFooter: Structure.isBitSet(flags, 30),
            isHeader: Structure.isBitSet(flags, 31),
            readOnly: Structure.isBitSet(flags, 0),
            dataType: (flags & 6) >> 1
        };
    };
    /**
     * @param num {number}
     * @param bit 0 is least significant bit (LSB)
     * @return {boolean} true if bit is 1; otherwise false
     */
    Structure.isBitSet = function (num, bit) {
        return (num & 1 << bit) !== 0;
    };
    /**
     * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum
     */
    Structure.DescriptorParser = {
        len: 52,
        get: function (buf, off) {
            return {
                // should equal 'MAC '
                ID: FourCC_1.FourCcToken.get(buf, off),
                // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
                version: Token.UINT32_LE.get(buf, off + 4) / 1000,
                // the number of descriptor bytes (allows later expansion of this header)
                descriptorBytes: Token.UINT32_LE.get(buf, off + 8),
                // the number of header APE_HEADER bytes
                headerBytes: Token.UINT32_LE.get(buf, off + 12),
                // the number of header APE_HEADER bytes
                seekTableBytes: Token.UINT32_LE.get(buf, off + 16),
                // the number of header data bytes (from original file)
                headerDataBytes: Token.UINT32_LE.get(buf, off + 20),
                // the number of bytes of APE frame data
                apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),
                // the high order number of APE frame data bytes
                apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),
                // the terminating data of the file (not including tag data)
                terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),
                // the MD5 hash of the file (see notes for usage... it's a littly tricky)
                fileMD5: new Token.BufferType(16).get(buf, off + 36)
            };
        }
    };
    /**
     * APE_HEADER: describes all of the necessary information about the APE file
     */
    Structure.Header = {
        len: 24,
        get: function (buf, off) {
            return {
                // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
                compressionLevel: Token.UINT16_LE.get(buf, off),
                // any format flags (for future use)
                formatFlags: Token.UINT16_LE.get(buf, off + 2),
                // the number of audio blocks in one frame
                blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),
                // the number of audio blocks in the final frame
                finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),
                // the total number of frames
                totalFrames: Token.UINT32_LE.get(buf, off + 12),
                // the bits per sample (typically 16)
                bitsPerSample: Token.UINT16_LE.get(buf, off + 16),
                // the number of channels (1 or 2)
                channel: Token.UINT16_LE.get(buf, off + 18),
                // the sample rate (typically 44100)
                sampleRate: Token.UINT32_LE.get(buf, off + 20)
            };
        }
    };
    /**
     * TAG: describes all the properties of the file [optional]
     */
    Structure.TagFooter = {
        len: 32,
        get: function (buf, off) {
            return {
                // should equal 'APETAGEX'
                ID: new Token.StringType(8, "ascii").get(buf, off),
                // equals CURRENT_APE_TAG_VERSION
                version: Token.UINT32_LE.get(buf, off + 8),
                // the complete size of the tag, including this footer (excludes header)
                size: Token.UINT32_LE.get(buf, off + 12),
                // the number of fields in the tag
                fields: Token.UINT32_LE.get(buf, off + 16),
                // reserved for later use (must be zero)
                reserved: new Token.BufferType(12).get(buf, off + 20) // ToDo: what is this???
            };
        }
    };
    Structure.TagField = function (footer) {
        return new Token.BufferType(footer.size - Structure.TagFooter.len);
    };
    return Structure;
}());
var APEv2Parser = /** @class */ (function () {
    function APEv2Parser() {
        this.type = "APEv2"; // ToDo: versionIndex should be made dynamic, APE may also contain ID3
        this.ape = {};
    }
    /**
     * Calculate the media file duration
     * @param ah ApeHeader
     * @return {number} duration in seconds
     */
    APEv2Parser.calculateDuration = function (ah) {
        var duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;
        duration += ah.finalFrameBlocks;
        return duration / ah.sampleRate;
    };
    APEv2Parser.parseFooter = function (tokenizer, options) {
        return tokenizer.readToken(Structure.TagFooter).then(function (footer) {
            if (footer.ID !== "APETAGEX") {
                throw new Error("Expected footer to start with APETAGEX ");
            }
            return tokenizer.readToken(Structure.TagField(footer)).then(function (tags) {
                return APEv2Parser.parseTags(footer, tags, !options.skipCovers);
            });
        });
    };
    // ToDo: public ???
    APEv2Parser.parseTags = function (footer, buffer, includeCovers) {
        var offset = 0;
        var tags = [];
        for (var i = 0; i < footer.fields; i++) {
            var size = Token.UINT32_LE.get(buffer, offset);
            offset += 4;
            var flags = Structure.parseTagFlags(Token.UINT32_LE.get(buffer, offset));
            offset += 4;
            var zero = Util_1.default.findZero(buffer, offset, buffer.length);
            var key = buffer.toString("ascii", offset, zero);
            offset = zero + 1;
            switch (flags.dataType) {
                case DataType.text_utf8: { // utf-8 textstring
                    var value = buffer.toString("utf8", offset, offset += size);
                    var values = value.split(/\x00/g);
                    /*jshint loopfunc:true */
                    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                        var val = values_1[_i];
                        tags.push({ id: key, value: val });
                    }
                    break;
                }
                case DataType.binary: // binary (probably artwork)
                    if (includeCovers) {
                        var picData = buffer.slice(offset, offset + size);
                        var off = 0;
                        zero = Util_1.default.findZero(picData, off, picData.length);
                        var description = picData.toString("utf8", off, zero);
                        off = zero + 1;
                        var data = Buffer.from(picData.slice(off));
                        var fileType = FileType(data);
                        if (fileType) {
                            if (fileType.mime.indexOf('image/') === 0) {
                                var picture = {
                                    description: description,
                                    data: data,
                                    format: fileType.mime
                                };
                                offset += size;
                                tags.push({ id: key, value: picture });
                            }
                            else {
                                debug('Unexpected binary tag of type ' + fileType.mime);
                            }
                        }
                        else {
                            debug('Failed to determine file type for binary tag: ' + key);
                        }
                    }
                    break;
                default:
                    throw new Error("Unexpected data-type: " + flags.dataType);
            }
        }
        return tags;
    };
    APEv2Parser.prototype.parse = function (tokenizer, options) {
        var _this = this;
        this.tokenizer = tokenizer;
        this.options = options;
        return this.tokenizer.readToken(Structure.DescriptorParser)
            .then(function (descriptor) {
            if (descriptor.ID !== "MAC ") {
                throw new Error("Expected MAC on beginning of file"); // ToDo: strip/parse JUNK
            }
            _this.ape.descriptor = descriptor;
            var lenExp = descriptor.descriptorBytes - Structure.DescriptorParser.len;
            if (lenExp > 0) {
                return _this.parseDescriptorExpansion(lenExp);
            }
            else {
                return _this.parseHeader();
            }
        }).then(function (header) {
            return _this.tokenizer.readToken(new Token.IgnoreType(header.forwardBytes)).then(function () {
                return APEv2Parser.parseFooter(tokenizer, options).then(function (tags) {
                    return {
                        format: header.format,
                        native: {
                            APEv2: tags
                        }
                    };
                });
            });
        });
    };
    APEv2Parser.prototype.parseDescriptorExpansion = function (lenExp) {
        var _this = this;
        return this.tokenizer.readToken(new Token.IgnoreType(lenExp)).then(function () {
            return _this.parseHeader();
        });
    };
    APEv2Parser.prototype.parseHeader = function () {
        var _this = this;
        return this.tokenizer.readToken(Structure.Header).then(function (header) {
            return {
                format: {
                    lossless: true,
                    dataformat: "Monkey's Audio",
                    headerType: _this.type,
                    bitsPerSample: header.bitsPerSample,
                    sampleRate: header.sampleRate,
                    numberOfChannels: header.channel,
                    duration: APEv2Parser.calculateDuration(header)
                },
                forwardBytes: _this.ape.descriptor.seekTableBytes + _this.ape.descriptor.headerDataBytes +
                    _this.ape.descriptor.apeFrameDataBytes + _this.ape.descriptor.terminatingDataBytes
            };
        });
    };
    return APEv2Parser;
}());
exports.APEv2Parser = APEv2Parser;
