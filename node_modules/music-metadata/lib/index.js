'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var GenericTagTypes_1 = require("./common/GenericTagTypes");
var ParserFactory_1 = require("./ParserFactory");
var ID3v24TagMapper_1 = require("./id3v2/ID3v24TagMapper");
var MP4TagMapper_1 = require("./mp4/MP4TagMapper");
var VorbisTagMapper_1 = require("./vorbis/VorbisTagMapper");
var APEv2TagMapper_1 = require("./apev2/APEv2TagMapper");
var ID3v22TagMapper_1 = require("./id3v2/ID3v22TagMapper");
var ID3v1TagMap_1 = require("./id3v1/ID3v1TagMap");
var AsfTagMapper_1 = require("./asf/AsfTagMapper");
var RiffInfoTagMap_1 = require("./riff/RiffInfoTagMap");
/**
 * Combines all generic-tag-mappers for each tag type
 */
var CombinedTagMapper = /** @class */ (function () {
    function CombinedTagMapper() {
        var _this = this;
        this.tagMappers = {};
        [
            new ID3v1TagMap_1.ID3v1TagMapper(),
            new ID3v22TagMapper_1.ID3v22TagMapper(),
            new ID3v24TagMapper_1.ID3v24TagMapper(),
            new MP4TagMapper_1.MP4TagMapper(),
            new MP4TagMapper_1.MP4TagMapper(),
            new VorbisTagMapper_1.VorbisTagMapper(),
            new APEv2TagMapper_1.APEv2TagMapper(),
            new AsfTagMapper_1.AsfTagMapper(),
            new RiffInfoTagMap_1.RiffInfoTagMapper()
        ].forEach(function (mapper) {
            _this.registerTagMapper(mapper);
        });
    }
    /**
     * Process and set common tags
     * @param comTags Target metadata to
     * write common tags to
     * @param comTags Generic tag results (output of this function)
     * @param tag     Native tag
     */
    CombinedTagMapper.prototype.setGenericTag = function (comTags, tagType, tag) {
        var tagMapper = this.tagMappers[tagType];
        if (tagMapper) {
            this.tagMappers[tagType].setGenericTag(comTags, tag);
        }
        else {
            throw new Error("No generic tag mapper defined for tag-format: " + tagType);
        }
    };
    CombinedTagMapper.prototype.registerTagMapper = function (genericTagMapper) {
        for (var _i = 0, _a = genericTagMapper.tagTypes; _i < _a.length; _i++) {
            var tagType = _a[_i];
            this.tagMappers[tagType] = genericTagMapper;
        }
    };
    return CombinedTagMapper;
}());
exports.CombinedTagMapper = CombinedTagMapper;
var MusicMetadataParser = /** @class */ (function () {
    function MusicMetadataParser() {
        this.tagMapper = new CombinedTagMapper();
    }
    MusicMetadataParser.getInstance = function () {
        return new MusicMetadataParser();
    };
    MusicMetadataParser.joinArtists = function (artists) {
        if (artists.length > 2) {
            return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];
        }
        return artists.join(' & ');
    };
    /**
     * Extract metadata from the given audio file
     * @param filePath File path of the audio file to parse
     * @param opts
     *   .filesize=true  Return filesize
     *   .native=true    Will return original header in result
     * @returns {Promise<IAudioMetadata>}
     */
    MusicMetadataParser.prototype.parseFile = function (filePath, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        return ParserFactory_1.ParserFactory.parseFile(filePath, opts).then(function (nativeData) {
            return _this.parseNativeTags(nativeData, opts.native, opts.mergeTagHeaders);
        });
    };
    /**
     * Extract metadata from the given audio file
     * @param stream Audio ReadableStream
     * @param mimeType Mime-Type of Stream
     * @param opts
     *   .filesize=true  Return filesize
     *   .native=true    Will return original header in result
     * @returns {Promise<IAudioMetadata>}
     */
    MusicMetadataParser.prototype.parseStream = function (stream, mimeType, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        return ParserFactory_1.ParserFactory.parseStream(stream, mimeType, opts).then(function (nativeData) {
            return _this.parseNativeTags(nativeData, opts.native, opts.mergeTagHeaders);
        });
    };
    /**
     * Convert native tags to common tags
     * @param nativeData
     * @includeNative return native tags in result
     * @returns {IAudioMetadata} Native + common tags
     */
    MusicMetadataParser.prototype.parseNativeTags = function (nativeData, includeNative, mergeTagHeaders) {
        var metadata = {
            format: nativeData.format,
            native: includeNative ? nativeData.native : undefined,
            common: {}
        };
        metadata.format.tagTypes = [];
        for (var tagType in nativeData.native) {
            metadata.format.tagTypes.push(tagType);
        }
        for (var _i = 0, TagPriority_1 = GenericTagTypes_1.TagPriority; _i < TagPriority_1.length; _i++) {
            var tagType = TagPriority_1[_i];
            if (nativeData.native[tagType]) {
                if (nativeData.native[tagType].length === 0) {
                    // ToDo: register warning: empty tag header
                }
                else {
                    var common = {
                        track: { no: null, of: null },
                        disk: { no: null, of: null }
                    };
                    for (var _a = 0, _b = nativeData.native[tagType]; _a < _b.length; _a++) {
                        var tag = _b[_a];
                        this.tagMapper.setGenericTag(common, tagType, tag);
                    }
                    for (var _c = 0, _d = Object.keys(common); _c < _d.length; _c++) {
                        var tag = _d[_c];
                        if (!metadata.common[tag]) {
                            metadata.common[tag] = common[tag];
                        }
                    }
                    if (!mergeTagHeaders) {
                        break;
                    }
                }
            }
        }
        if (metadata.common.artists && metadata.common.artists.length > 0) {
            // common.artists explicitly by meta-data
            metadata.common.artist = !metadata.common.artist ? MusicMetadataParser.joinArtists(metadata.common.artists) : metadata.common.artist[0];
        }
        else {
            if (metadata.common.artist) {
                metadata.common.artists = metadata.common.artist;
                if (metadata.common.artist.length > 1) {
                    delete metadata.common.artist;
                }
                else {
                    metadata.common.artist = metadata.common.artist[0];
                }
            }
        }
        return metadata;
    };
    return MusicMetadataParser;
}());
exports.MusicMetadataParser = MusicMetadataParser;
/**
 * Parse audio file
 * @param filePath Media file to read meta-data from
 * @param options Parsing options:
 *   .native=true    Will return original header in result
 *   .mergeTagHeaders=false  Populate common from data of all headers available
 * @returns {Promise<IAudioMetadata>}
 */
function parseFile(filePath, options) {
    return MusicMetadataParser.getInstance().parseFile(filePath, options);
}
exports.parseFile = parseFile;
/**
 * Parse audio Stream
 * @param stream
 * @param mimeType
 * @param opts Parsing options
 *   .native=true    Will return original header in result
 *   .mergeTagHeaders=false  Populate common from data of all headers available
 * @returns {Promise<IAudioMetadata>}
 */
function parseStream(stream, mimeType, opts) {
    return MusicMetadataParser.getInstance().parseStream(stream, mimeType, opts);
}
exports.parseStream = parseStream;
/**
 * Create a dictionary ordered by their tag id (key)
 * @param nativeTags list of tags
 * @returns tags indexed by id
 */
function orderTags(nativeTags) {
    var tags = {};
    for (var _i = 0, nativeTags_1 = nativeTags; _i < nativeTags_1.length; _i++) {
        var tag = nativeTags_1[_i];
        (tags[tag.id] = (tags[tag.id] || [])).push(tag.value);
    }
    return tags;
}
exports.orderTags = orderTags;
/**
 * Convert rating to 1-5 star rating
 * @param {number} rating Normalized rating [0..1] (common.rating[n].rating)
 * @returns {number} Number of stars: 1, 2, 3, 4 or 5 stars
 */
function ratingToStars(rating) {
    return rating === undefined ? 0 : 1 + Math.round(rating * 4);
}
exports.ratingToStars = ratingToStars;
