"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var APEv2Parser_1 = require("./apev2/APEv2Parser");
var AsfParser_1 = require("./asf/AsfParser");
var FlacParser_1 = require("./flac/FlacParser");
var MP4Parser_1 = require("./mp4/MP4Parser");
var OggParser_1 = require("./ogg/OggParser");
var strtok3 = require("strtok3");
var path = require("path");
var AiffParser_1 = require("./aiff/AiffParser");
var RiffParser_1 = require("./riff/RiffParser");
var WavPackParser_1 = require("./wavpack/WavPackParser");
var MpegParser_1 = require("./mpeg/MpegParser");
var fileType = require("file-type");
var MimeType = require("media-typer");
var _debug = require("debug");
var debug = _debug("music-metadata:parser:factory");
var ParserFactory = /** @class */ (function () {
    function ParserFactory() {
        // ToDo: expose warnings to API
        this.warning = [];
    }
    /**
     * Extract metadata from the given audio file
     * @param filePath File path of the audio file to parse
     * @param opts
     *   .fileSize=true  Return filesize
     *   .native=true    Will return original header in result
     * @returns {Promise<INativeAudioMetadata>}
     */
    ParserFactory.parseFile = function (filePath, opts) {
        if (opts === void 0) { opts = {}; }
        return strtok3.fromFile(filePath).then(function (fileTokenizer) {
            var parser = ParserFactory.getParserForExtension(filePath);
            if (parser) {
                return parser.parse(fileTokenizer, opts).then(function (metadata) {
                    return fileTokenizer.close().then(function () {
                        return metadata;
                    });
                }).catch(function (err) {
                    return fileTokenizer.close().then(function () {
                        throw err;
                    });
                });
            }
            else {
                throw new Error('No parser found for extension: ' + path.extname(filePath));
            }
        });
    };
    /**
     * Parse metadata from stream
     * @param stream Node stream
     * @param mimeType The mime-type, e.g. "audio/mpeg", extension e.g. ".mp3" or filename. This is used to redirect to the correct parser.
     * @param opts Parsing options
     * @returns {Promise<INativeAudioMetadata>}
     */
    ParserFactory.parseStream = function (stream, mimeType, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        return strtok3.fromStream(stream).then(function (tokenizer) {
            if (!tokenizer.fileSize && opts.fileSize) {
                tokenizer.fileSize = opts.fileSize;
            }
            return _this.parse(tokenizer, mimeType, opts);
        });
    };
    /**
     *  Parse metadata from tokenizer
     * @param {ITokenizer} tokenizer
     * @param {string} contentType
     * @param {IOptions} opts
     * @returns {Promise<INativeAudioMetadata>}
     */
    ParserFactory.parse = function (tokenizer, contentType, opts) {
        if (opts === void 0) { opts = {}; }
        // Resolve parser based on MIME-type or file extension
        var parser = ParserFactory.getParserForMimeType(contentType) || ParserFactory.getParserForExtension(contentType);
        if (!parser) {
            // No MIME-type mapping found
            debug("No parser found for MIME-type / extension:" + contentType);
            var buf_1 = Buffer.alloc(4100);
            return tokenizer.peekBuffer(buf_1).then(function () {
                var guessedType = fileType(buf_1);
                if (!guessedType)
                    throw new Error("Failed to guess MIME-type");
                parser = ParserFactory.getParserForMimeType(guessedType.mime);
                if (!parser)
                    throw new Error("Guessed MIME-type not supported: " + guessedType.mime);
                return parser.parse(tokenizer, opts);
            });
        }
        // Parser found, execute parser
        return parser.parse(tokenizer, opts);
    };
    /**
     * @param filePath Path, filename or extension to audio file
     * @return ITokenParser if extension is supported; otherwise false
     */
    ParserFactory.getParserForExtension = function (filePath) {
        if (!filePath)
            return;
        var extension = path.extname(filePath).toLocaleLowerCase() || filePath;
        switch (extension) {
            case ".mp2":
            case ".mp3":
            case ".m2a":
                return new MpegParser_1.MpegParser();
            case ".ape":
                return new APEv2Parser_1.APEv2Parser();
            case ".aac":
            case ".mp4":
            case ".m4a":
            case ".m4b":
            case ".m4pa":
            case ".m4v":
            case ".m4r":
            case ".3gp":
                return new MP4Parser_1.MP4Parser();
            case ".wma":
            case ".wmv":
            case ".asf":
                return new AsfParser_1.AsfParser();
            case ".flac":
                return new FlacParser_1.FlacParser();
            case ".ogg":
            case ".ogv":
            case ".oga":
            case ".ogx":
            case ".opus": // recommended filename extension for Ogg Opus files
                return new OggParser_1.OggParser();
            case ".aif":
            case ".aiff":
            case ".aifc":
                return new AiffParser_1.AIFFParser();
            case ".wav":
                return new RiffParser_1.WavePcmParser();
            case ".wv":
            case ".wvp":
                return new WavPackParser_1.WavPackParser();
        }
    };
    /**
     * @param {string} mimeType MIME-Type, extension, path or filename
     * @returns ITokenParser if MIME-type is supported; otherwise false
     */
    ParserFactory.getParserForMimeType = function (mimeType) {
        var mime;
        try {
            mime = MimeType.parse(mimeType);
        }
        catch (err) {
            debug("Invalid MIME-type: " + mimeType);
            return;
        }
        var subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;
        switch (mime.type) {
            case 'audio':
                switch (subType) {
                    case 'mpeg':
                        return new MpegParser_1.MpegParser(); // ToDo: handle ID1 header as well
                    case 'flac':
                        return new FlacParser_1.FlacParser();
                    case 'ape':
                    case 'monkeys-audio':
                        return new APEv2Parser_1.APEv2Parser();
                    case 'mp4':
                    case 'aac':
                    case 'aacp':
                    case 'm4a':
                        return new MP4Parser_1.MP4Parser();
                    case 'ogg': // RFC 7845
                        return new OggParser_1.OggParser();
                    case 'ms-wma':
                        return new AsfParser_1.AsfParser();
                    case 'aiff':
                    case 'aif':
                    case 'aifc':
                        return new AiffParser_1.AIFFParser();
                    case 'vnd.wave':
                    case 'wav':
                    case 'wave':
                        return new RiffParser_1.WavePcmParser();
                    case 'wavpack':
                        return new WavPackParser_1.WavPackParser();
                }
                break;
            case 'video':
                switch (subType) {
                    case 'ms-asf':
                        return new AsfParser_1.AsfParser();
                    case 'ogg':
                        return new OggParser_1.OggParser();
                }
                break;
            case 'application':
                switch (subType) {
                    case 'ogg':
                        return new OggParser_1.OggParser();
                }
                break;
        }
    };
    return ParserFactory;
}());
exports.ParserFactory = ParserFactory;
