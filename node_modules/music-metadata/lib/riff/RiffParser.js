"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var strtok3 = require("strtok3");
var Token = require("token-types");
var RiffChunk = require("./RiffChunk");
var WaveChunk = require("./../wav/WaveChunk");
var stream_1 = require("stream");
var ID3v2Parser_1 = require("../id3v2/ID3v2Parser");
var Util_1 = require("../common/Util");
var FourCC_1 = require("../common/FourCC");
var es6_promise_1 = require("es6-promise");
var _debug = require("debug");
var debug = _debug("music-metadata:parser:RIFF");
/**
 * Resource Interchange File Format (RIFF) Parser
 *
 * WAVE PCM soundfile format
 *
 * Ref:
 *  http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html
 *  http://soundfile.sapp.org/doc/WaveFormat
 *
 *  ToDo: Split WAVE part from RIFF parser
 */
var WavePcmParser = /** @class */ (function () {
    function WavePcmParser() {
        this.metadata = {
            format: {
                dataformat: "WAVE/?",
                lossless: true
            },
            native: {}
        };
        /**
         * RIFF/ILIST-INFO tag stored in EXIF
         */
        this.riffInfoTags = [];
        this.warnings = [];
    }
    WavePcmParser.prototype.parse = function (tokenizer, options) {
        var _this = this;
        this.tokenizer = tokenizer;
        this.options = options;
        return this.tokenizer.readToken(RiffChunk.Header)
            .then(function (riffHeader) {
            debug('pos=%s, parse: chunkID=%s', _this.tokenizer.position, riffHeader.chunkID);
            if (riffHeader.chunkID !== 'RIFF')
                return null; // Not RIFF format
            return _this.parseRiffChunk();
        })
            .catch(function (err) {
            if (err.message === strtok3.endOfFile) {
                return _this.metadata;
            }
            else {
                throw err;
            }
        }).then(function (metadata) {
            if (_this.riffInfoTags.length > 0) {
                metadata.native.exif = _this.riffInfoTags;
            }
            return metadata;
        });
    };
    WavePcmParser.prototype.parseRiffChunk = function () {
        var _this = this;
        return this.tokenizer.readToken(FourCC_1.FourCcToken).then(function (type) {
            _this.metadata.format.dataformat = type;
            switch (type) {
                case "WAVE":
                    return _this.readWaveChunk();
                default:
                    throw new Error("Unsupported RIFF format: RIFF/" + type);
            }
        });
    };
    WavePcmParser.prototype.readWaveChunk = function () {
        var _this = this;
        return this.tokenizer.readToken(RiffChunk.Header)
            .then(function (header) {
            debug('pos=%s, readChunk: chunkID=RIFF/WAVE/%s', _this.tokenizer.position, header.chunkID);
            switch (header.chunkID) {
                case "LIST":
                    return _this.parseListTag(header);
                case 'fact': // extended Format chunk,
                    _this.metadata.format.lossless = false;
                    return _this.tokenizer.readToken(new WaveChunk.FactChunk(header)).then(function (fact) {
                        _this.fact = fact;
                    });
                case "fmt ": // The Util Chunk, non-PCM Formats
                    return _this.tokenizer.readToken(new WaveChunk.Format(header))
                        .then(function (fmt) {
                        _this.metadata.format.dataformat = WaveChunk.WaveFormat[fmt.wFormatTag];
                        if (!_this.metadata.format.dataformat) {
                            debug("WAVE/non-PCM format=" + fmt.wFormatTag);
                            _this.metadata.format.dataformat = "non-PCM (" + fmt.wFormatTag + ")";
                        }
                        _this.metadata.format.dataformat = "WAVE/" + _this.metadata.format.dataformat;
                        _this.metadata.format.bitsPerSample = fmt.wBitsPerSample;
                        _this.metadata.format.sampleRate = fmt.nSamplesPerSec;
                        _this.metadata.format.numberOfChannels = fmt.nChannels;
                        _this.metadata.format.bitrate = fmt.nBlockAlign * fmt.nSamplesPerSec * 8;
                        _this.blockAlign = fmt.nBlockAlign;
                    });
                case "id3 ": // The way Picard, FooBar currently stores, ID3 meta-data
                case "ID3 ": // The way Mp3Tags stores ID3 meta-data
                    return _this.tokenizer.readToken(new Token.BufferType(header.size))
                        .then(function (id3_data) {
                        var id3stream = new ID3Stream(id3_data);
                        return strtok3.fromStream(id3stream).then(function (rst) {
                            return ID3v2Parser_1.ID3v2Parser.getInstance().parse(_this.metadata, rst, _this.options);
                        });
                    });
                case 'data': // PCM-data
                    _this.metadata.format.numberOfSamples = _this.fact ? _this.fact.dwSampleLength : (header.size / _this.blockAlign);
                    _this.metadata.format.duration = _this.metadata.format.numberOfSamples / _this.metadata.format.sampleRate;
                    _this.metadata.format.bitrate = _this.metadata.format.numberOfChannels * _this.blockAlign * _this.metadata.format.sampleRate; // ToDo: check me
                    return _this.tokenizer.ignore(header.size);
                default:
                    debug("Ignore chunk: RIFF/" + header.chunkID);
                    _this.warnings.push("Ignore chunk: RIFF/" + header.chunkID);
                    return _this.tokenizer.ignore(header.size);
            }
        }).then(function () {
            return _this.readWaveChunk();
        });
    };
    WavePcmParser.prototype.parseListTag = function (listHeader) {
        var _this = this;
        return this.tokenizer.readToken(FourCC_1.FourCcToken).then(function (listType) {
            debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', _this.tokenizer.position, listType);
            switch (listType) {
                case 'INFO':
                    return _this.parseRiffInfoTags(listHeader.size - 4);
                default:
                    _this.warnings.push("Ignore chunk: RIFF/WAVE/LIST/" + listType);
                    debug("Ignoring chunkID=RIFF/WAVE/LIST/" + listType);
                case 'adtl':
                    return _this.tokenizer.ignore(listHeader.size - 4);
            }
        });
    };
    WavePcmParser.prototype.parseRiffInfoTags = function (chunkSize) {
        var _this = this;
        if (chunkSize === 0) {
            return es6_promise_1.Promise.resolve(null);
        }
        return this.tokenizer.readToken(RiffChunk.Header)
            .then(function (header) {
            var valueToken = new RiffChunk.ListInfoTagValue(header);
            return _this.tokenizer.readToken(valueToken).then(function (value) {
                _this.riffInfoTags.push({ id: header.chunkID, value: Util_1.default.stripNulls(value) });
                chunkSize -= (8 + valueToken.len);
                if (chunkSize >= 8) {
                    return _this.parseRiffInfoTags(chunkSize);
                }
                else if (chunkSize !== 0) {
                    throw Error("Illegal remaining size: " + chunkSize);
                }
            });
        });
    };
    return WavePcmParser;
}());
exports.WavePcmParser = WavePcmParser;
var ID3Stream = /** @class */ (function (_super) {
    __extends(ID3Stream, _super);
    function ID3Stream(buf) {
        var _this = _super.call(this) || this;
        _this.buf = buf;
        return _this;
    }
    ID3Stream.prototype._read = function () {
        this.push(this.buf);
        this.push(null); // push the EOF-signaling `null` chunk
    };
    return ID3Stream;
}(stream_1.Readable));
