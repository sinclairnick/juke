"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var generic = require("./GenericTagTypes");
var ID3v1Parser_1 = require("../id3v1/ID3v1Parser");
var CommonTagMapper = /** @class */ (function () {
    function CommonTagMapper(tagTypes, tagMap) {
        this.tagTypes = tagTypes;
        this.tagMap = tagMap;
    }
    CommonTagMapper.parseGenre = function (origVal) {
        // match everything inside parentheses
        var split = origVal.trim().split(/\((.*?)\)/g).filter(function (val) {
            return val !== '';
        });
        var array = [];
        for (var _i = 0, split_1 = split; _i < split_1.length; _i++) {
            var cur = split_1[_i];
            if (/^\d+$/.test(cur) && !isNaN(parseInt(cur, 10))) {
                cur = ID3v1Parser_1.Genres[cur];
            }
            array.push(cur);
        }
        return array
            .filter(function (val) {
            return val !== undefined;
        }).join('/');
    };
    CommonTagMapper.fixPictureMimeType = function (pictureType) {
        pictureType = pictureType.toLocaleLowerCase();
        switch (pictureType) {
            case 'image/jpg':
                return 'image/jpeg'; // ToDo: register warning
        }
        return pictureType;
    };
    CommonTagMapper.toIntOrNull = function (str) {
        var cleaned = parseInt(str, 10);
        return isNaN(cleaned) ? null : cleaned;
    };
    // TODO: a string of 1of1 would fail to be converted
    // converts 1/10 to no : 1, of : 10
    // or 1 to no : 1, of : 0
    CommonTagMapper.normalizeTrack = function (origVal) {
        var split = origVal.toString().split('/');
        return {
            no: parseInt(split[0], 10) || null,
            of: parseInt(split[1], 10) || null
        };
    };
    /**
     * Process and set common tags
     * @param comTags Target metadata to
     * write common tags to
     * @param comTags Generic tag results (output of this function)
     * @param tag     Native tag
     * @param value   Native tag value
     */
    CommonTagMapper.prototype.setGenericTag = function (comTags, tag) {
        tag = { id: tag.id, value: tag.value }; // clone object
        this.postMap(tag);
        // Convert native tag event to generic 'alias' tag
        var alias = this.getCommonName(tag.id);
        if (alias) {
            // Common tag (alias) found
            // check if we need to do something special with common tag
            // if the event has been aliased then we need to clean it before
            // it is emitted to the user. e.g. genre (20) -> Electronic
            switch (alias) {
                case 'genre':
                    tag.value = CommonTagMapper.parseGenre(tag.value);
                    break;
                case 'picture':
                    tag.value.format = CommonTagMapper.fixPictureMimeType(tag.value.format);
                    break;
                case 'totaltracks':
                    comTags.track.of = CommonTagMapper.toIntOrNull(tag.value);
                    return;
                case 'totaldiscs':
                    comTags.disk.of = CommonTagMapper.toIntOrNull(tag.value);
                    return;
                case 'track':
                case 'disk':
                    var of = comTags[alias].of; // store of value, maybe maybe overwritten
                    comTags[alias] = CommonTagMapper.normalizeTrack(tag.value);
                    comTags[alias].of = of != null ? of : comTags[alias].of;
                    return;
                case 'year':
                case 'originalyear':
                    tag.value = parseInt(tag.value, 10);
                    break;
                case 'date':
                    // ToDo: be more strict on 'YYYY...'
                    var year = parseInt(tag.value.substr(0, 4), 10);
                    if (year && !isNaN(year)) {
                        comTags.year = year;
                    }
                    break;
                case 'discogs_release_id':
                    tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;
                    break;
                case 'replaygain_track_peak':
                    tag.value = typeof tag.value === 'string' ? parseFloat(tag.value) : tag.value;
                    break;
                case 'gapless': // iTunes gap-less flag
                    tag.value = tag.value === "1"; // boolean
                    break;
                default:
                // nothing to do
            }
            if (alias !== 'artist' && generic.isSingleton(alias)) {
                comTags[alias] = tag.value;
            }
            else {
                if (comTags.hasOwnProperty(alias)) {
                    comTags[alias].push(tag.value);
                }
                else {
                    // if we haven't previously seen this tag then
                    // initialize it to an array, ready for values to be entered
                    comTags[alias] = [tag.value];
                }
            }
        }
    };
    /**
     * Convert native tag key to common tag key
     * @tag  Native header tag
     * @return common tag name (alias)
     */
    CommonTagMapper.prototype.getCommonName = function (tag) {
        return this.tagMap[tag];
    };
    /**
     * Handle post mapping exceptions / correction
     * @param {string} tag Tag e.g. {"Â©alb", "Buena Vista Social Club")
     */
    CommonTagMapper.prototype.postMap = function (tag) {
        return;
    };
    CommonTagMapper.maxRatingScore = 1;
    return CommonTagMapper;
}());
exports.CommonTagMapper = CommonTagMapper;
