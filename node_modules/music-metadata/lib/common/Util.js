"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
var Windows1292Decoder_1 = require("./Windows1292Decoder");
var Util = /** @class */ (function () {
    function Util() {
    }
    /**
     *
     * @param buffer
     * @param start
     * @param end
     * @param encoding // ToDo: ts.enum
     * @return {number}
     */
    Util.findZero = function (buffer, start, end, encoding) {
        var i = start;
        if (encoding === 'utf16') {
            while (buffer[i] !== 0 || buffer[i + 1] !== 0) {
                if (i >= end)
                    return end;
                i += 2;
            }
            return i;
        }
        else {
            while (buffer[i] !== 0) {
                if (i >= end)
                    return end;
                i++;
            }
            return i;
        }
    };
    Util.swapBytes = function (buffer) {
        var l = buffer.length;
        assert.ok((l & 1) === 0, 'Buffer length must be even');
        for (var i = 0; i < l; i += 2) {
            var a = buffer[i];
            buffer[i] = buffer[i + 1];
            buffer[i + 1] = a;
        }
        return buffer;
    };
    Util.readUTF16String = function (buffer) {
        var offset = 0;
        if (buffer[0] === 0xFE && buffer[1] === 0xFF) { // big endian
            buffer = Util.swapBytes(buffer);
            offset = 2;
        }
        else if (buffer[0] === 0xFF && buffer[1] === 0xFE) { // little endian
            offset = 2;
        }
        return buffer.toString('ucs2', offset);
    };
    /**
     *
     * @param buffer Decoder input data
     * @param encoding 'utf16le' | 'utf16' | 'utf8' | 'iso-8859-1'
     * @return {string}
     */
    Util.decodeString = function (buffer, encoding) {
        // annoying workaround for a double BOM issue
        // https://github.com/leetreveil/musicmetadata/issues/84
        if (buffer[0] === 0xFF && buffer[1] === 0xFE && buffer[2] === 0xFE && buffer[3] === 0xFF) {
            buffer = buffer.slice(2);
        }
        if (encoding === 'utf16le' || encoding === 'utf16') {
            return Util.readUTF16String(buffer);
        }
        else if (encoding === 'utf8') {
            return buffer.toString('utf8');
        }
        else if (encoding === 'iso-8859-1') {
            return Windows1292Decoder_1.Windows1292Decoder.decode(buffer);
        }
        throw Error(encoding + ' encoding is not supported!');
    };
    Util.stripNulls = function (str) {
        str = str.replace(/^\x00+/g, '');
        str = str.replace(/\x00+$/g, '');
        return str;
    };
    /**
     * Read bit-aligned number start from buffer
     * Total offset in bits = byteOffset * 8 + bitOffset
     * @param buf Byte buffer
     * @param byteOffset Starting offset in bytes
     * @param bitOffset Starting offset in bits: 0 = lsb
     * @param len Length of number in bits
     * @return {number} decoded bit aligned number
     */
    Util.getBitAllignedNumber = function (buf, byteOffset, bitOffset, len) {
        var byteOff = byteOffset + ~~(bitOffset / 8);
        var bitOff = bitOffset % 8;
        var value = buf[byteOff];
        value &= 0xff >> bitOff;
        var bitsRead = 8 - bitOff;
        var bitsLeft = len - bitsRead;
        if (bitsLeft < 0) {
            value >>= (8 - bitOff - len);
        }
        else if (bitsLeft > 0) {
            value <<= bitsLeft;
            value |= Util.getBitAllignedNumber(buf, byteOffset, bitOffset + bitsRead, bitsLeft);
        }
        return value;
    };
    /**
     * Read bit-aligned number start from buffer
     * Total offset in bits = byteOffset * 8 + bitOffset
     * @param buf Byte buffer
     * @param byteOffset Starting offset in bytes
     * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is least significant bit
     * @return {number} decoded bit aligned number
     */
    Util.isBitSet = function (buf, byteOffset, bitOffset) {
        return Util.getBitAllignedNumber(buf, byteOffset, bitOffset, 1) === 1;
    };
    /**
     * Best effort approach to read 64 but unsigned integer.
     * Note that JavasScript is limited to 2^53 - 1 bit.
     */
    Util.readUInt64LE = function (buf, offset) {
        if (offset === void 0) { offset = 0; }
        var n = buf[offset];
        var mul = 1;
        var i = 0;
        while (++i < 8) {
            mul *= 0x100;
            n += buf[offset + i] * mul;
        }
        return n;
    };
    /**
     * Best effort approach to read 64 but unsigned integer.
     * Note that JavasScript is limited to 2^53 - 1 bit.
     */
    Util.readIntBE = function (buf, offset, byteLength) {
        offset = offset >>> 0;
        byteLength = byteLength >>> 0;
        var i = byteLength;
        var mul = 1;
        var val = buf[offset + --i];
        while (i > 0) {
            mul *= 0x100;
            val += buf[offset + --i] * mul;
        }
        mul *= 0x80;
        if (val >= mul)
            val -= Math.pow(2, 8 * byteLength);
        return val;
    };
    /**
     * Best effort approach to read 64 but unsigned integer.
     * Note that JavasScript is limited to 2^53 - 1 bit.
     */
    Util.readUIntBE = function (buf, offset, byteLength) {
        offset = offset >>> 0;
        byteLength = byteLength >>> 0;
        var val = buf[offset + --byteLength];
        var mul = 1;
        while (byteLength > 0) {
            mul *= 0x100;
            val += buf[offset + --byteLength] * mul;
        }
        return val;
    };
    Util.strtokBITSET = {
        get: function (buf, off, bit) {
            return (buf[off] & (1 << bit)) !== 0;
        },
        len: 1
    };
    return Util;
}());
exports.default = Util;
