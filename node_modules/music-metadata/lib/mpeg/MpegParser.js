"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
var strtok3_1 = require("strtok3");
var Util_1 = require("../common/Util");
var Token = require("token-types");
var AbstractID3Parser_1 = require("../id3v2/AbstractID3Parser");
var XingTag_1 = require("./XingTag");
var es6_promise_1 = require("es6-promise");
var _debug = require("debug");
var debug = _debug("music-metadata:parser:mpeg");
/**
 * Cache buffer size used for searching synchronization preabmle
 */
var maxPeekLen = 1024;
/**
 * MPEG Audio Layer I/II/III frame header
 * Ref: https://www.mp3-tech.org/programmer/frame_header.html
 * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM
 */
var MpegFrameHeader = /** @class */ (function () {
    function MpegFrameHeader(buf, off) {
        // B(20,19): MPEG Audio versionIndex ID
        this.versionIndex = Util_1.default.getBitAllignedNumber(buf, off + 1, 3, 2);
        // C(18,17): Layer description
        this.layer = MpegFrameHeader.LayerDescription[Util_1.default.getBitAllignedNumber(buf, off + 1, 5, 2)];
        if (this.layer === null)
            throw new Error("Invalid MPEG layer");
        // D(16): Protection bit (if true 16-bit CRC follows header)
        this.isProtectedByCRC = !Util_1.default.isBitSet(buf, off + 1, 7);
        // E(15,12): Bitrate index
        this.bitrateIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 4);
        // F(11,10): Sampling rate frequency index
        this.sampRateFreqIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 4, 2);
        // G(9): Padding bit
        this.padding = Util_1.default.isBitSet(buf, off + 2, 6);
        // H(8): Private bit
        this.privateBit = Util_1.default.isBitSet(buf, off + 2, 7);
        // I(7,6): Channel Mode
        this.channelModeIndex = Util_1.default.getBitAllignedNumber(buf, off + 3, 0, 2);
        // J(5,4): Mode extension (Only used in Joint stereo)
        this.modeExtension = Util_1.default.getBitAllignedNumber(buf, off + 3, 2, 2);
        // K(3): Copyright
        this.isCopyrighted = Util_1.default.isBitSet(buf, off + 3, 4);
        // L(2): Original
        this.isOriginalMedia = Util_1.default.isBitSet(buf, off + 3, 5);
        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.
        this.emphasis = Util_1.default.getBitAllignedNumber(buf, off + 3, 7, 2);
        this.version = MpegFrameHeader.VersionID[this.versionIndex];
        if (this.version === null)
            throw new Error("Invalid MPEG Audio version");
        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];
        // Calculate bitrate
        var bitrateInKbps = this.calcBitrate();
        if (!bitrateInKbps) {
            throw new Error("Cannot determine bit-rate");
        }
        this.bitrate = bitrateInKbps === null ? null : bitrateInKbps * 1000;
        // Calculate sampling rate
        this.samplingRate = this.calcSamplingRate();
        if (this.samplingRate == null) {
            throw new Error("Cannot determine sampling-rate");
        }
    }
    MpegFrameHeader.prototype.calcDuration = function (numFrames) {
        return numFrames * this.calcSamplesPerFrame() / this.samplingRate;
    };
    MpegFrameHeader.prototype.calcSamplesPerFrame = function () {
        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
    };
    MpegFrameHeader.prototype.calculateSideInfoLength = function () {
        if (this.layer !== 3)
            return 2;
        if (this.channelModeIndex === 3) {
            // mono
            if (this.version === 1) {
                return 17;
            }
            else if (this.version === 2 || this.version === 2.5) {
                return 9;
            }
        }
        else {
            if (this.version === 1) {
                return 32;
            }
            else if (this.version === 2 || this.version === 2.5) {
                return 17;
            }
        }
    };
    MpegFrameHeader.prototype.calcSlotSize = function () {
        return [null, 4, 1, 1][this.layer];
    };
    MpegFrameHeader.prototype.calcBitrate = function () {
        if (this.bitrateIndex === 0x00)
            return null; // free
        if (this.bitrateIndex === 0x0F)
            return null; // 'reserved'
        var mpegVersion = this.version.toString() + this.layer;
        return MpegFrameHeader.bitrate_index[this.bitrateIndex][mpegVersion];
    };
    MpegFrameHeader.prototype.calcSamplingRate = function () {
        if (this.sampRateFreqIndex === 0x03)
            return null; // 'reserved'
        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
    };
    MpegFrameHeader.SyncByte1 = 0xFF;
    MpegFrameHeader.SyncByte2 = 0xE0;
    MpegFrameHeader.VersionID = [2.5, null, 2, 1];
    MpegFrameHeader.LayerDescription = [null, 3, 2, 1];
    MpegFrameHeader.ChannelMode = ["stereo", "joint_stereo", "dual_channel", "mono"];
    MpegFrameHeader.bitrate_index = {
        0x01: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
        0x02: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
        0x03: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
        0x04: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
        0x05: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
        0x06: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
        0x07: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
        0x08: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
        0x09: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
        0x0A: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
        0x0B: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
        0x0C: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
        0x0D: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
        0x0E: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }
    };
    MpegFrameHeader.sampling_rate_freq_index = {
        1: { 0x00: 44100, 0x01: 48000, 0x02: 32000 },
        2: { 0x00: 22050, 0x01: 24000, 0x02: 16000 },
        2.5: { 0x00: 11025, 0x01: 12000, 0x02: 8000 }
    };
    MpegFrameHeader.samplesInFrameTable = [
        /* Layer   I    II   III */
        [0, 384, 1152, 1152],
        [0, 384, 1152, 576] // MPEG-2(.5
    ];
    return MpegFrameHeader;
}());
/**
 * MPEG Audio Layer I/II/III
 */
var MpegAudioLayer = /** @class */ (function () {
    function MpegAudioLayer() {
    }
    MpegAudioLayer.getVbrCodecProfile = function (vbrScale) {
        return "V" + (100 - vbrScale) / 10;
    };
    MpegAudioLayer.FrameHeader = {
        len: 4,
        get: function (buf, off) {
            return new MpegFrameHeader(buf, off);
        }
    };
    return MpegAudioLayer;
}());
var MpegParser = /** @class */ (function (_super) {
    __extends(MpegParser, _super);
    function MpegParser() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.frameCount = 0;
        _this.countSkipFrameData = 0;
        _this.bitrates = [];
        _this.unsynced = 0;
        _this.warnings = [];
        _this.calculateEofDuration = false;
        _this.buf_frame_header = Buffer.alloc(4);
        _this.syncPeek = {
            buf: Buffer.alloc(maxPeekLen),
            len: 0
        };
        return _this;
    }
    /**
     * Called after ID3 headers have been parsed
     */
    MpegParser.prototype._parse = function (metadata, tokenizer, options) {
        var _this = this;
        this.metadata = metadata;
        this.tokenizer = tokenizer;
        this.readDuration = options.duration;
        var format = this.metadata.format;
        format.lossless = false;
        return this.sync().catch(function (err) {
            if (err.message === strtok3_1.endOfFile) {
                if (_this.calculateEofDuration) {
                    format.numberOfSamples = _this.frameCount * _this.samplesPerFrame;
                    format.duration = format.numberOfSamples / format.sampleRate;
                    debug("Calculate duration at EOF: %s", _this.metadata.format.duration);
                }
            }
            else {
                throw err;
            }
        });
    };
    /**
     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length
     * @param metadata
     * @returns {INativeAudioMetadata}
     */
    MpegParser.prototype.finalize = function (metadata) {
        var format = this.metadata.format;
        if (!format.duration && this.tokenizer.fileSize && format.codecProfile === "CBR") {
            var hasID3v1 = metadata.native.hasOwnProperty('ID3v1.1');
            var mpegSize = this.tokenizer.fileSize - this.mpegOffset - (hasID3v1 ? 128 : 0);
            format.numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;
            format.duration = format.numberOfSamples / format.sampleRate;
            debug("Calculate CBR duration based on file size: %s", format.duration);
        }
        return metadata;
    };
    MpegParser.prototype._peekBuffer = function () {
        var _this = this;
        this.unsynced += this.syncPeek.len;
        return this.tokenizer.ignore(this.syncPeek.len).then(function () {
            return _this.tokenizer.peekBuffer(_this.syncPeek.buf, 0, maxPeekLen).then(function (len) {
                _this.syncPeek.len = len;
                return len;
            });
        });
    };
    MpegParser.prototype._sync = function (offset, gotFirstSync) {
        var _this = this;
        return (offset === 0 ? this._peekBuffer() : es6_promise_1.Promise.resolve(this.syncPeek.buf.length - offset))
            .then(function (len) {
            if (gotFirstSync) {
                if (len === 0)
                    throw new Error(strtok3_1.endOfFile);
                if ((_this.syncPeek.buf[offset] & 0xE0) === 0xE0) {
                    _this.syncPeek.len = 0;
                    _this.unsynced += offset - 1;
                    return _this.tokenizer.ignore(offset); // Full sync
                }
                else {
                    return _this._sync((offset + 1) % _this.syncPeek.buf.length, false); // partial sync
                }
            }
            else {
                if (len <= 1)
                    throw new Error(strtok3_1.endOfFile);
                var index = _this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, offset);
                if (index >= 0) {
                    return _this._sync((index + 1) % _this.syncPeek.buf.length, true);
                }
                else {
                    return _this._sync(0, false);
                }
            }
        });
    };
    MpegParser.prototype.sync = function () {
        var _this = this;
        return this._sync(0, false)
            .then(function () {
            if (_this.unsynced > 0) {
                _this.warnings.push("synchronized, after " + _this.unsynced + " bytes of unsynced data");
                // debug("synchronized, after " + this.unsynced + " bytes of unsynced data");
                _this.unsynced = 0;
            }
            return _this.parseAudioFrameHeader(_this.buf_frame_header);
        });
    };
    MpegParser.prototype.parseAudioFrameHeader = function (buf_frame_header) {
        var _this = this;
        if (this.frameCount === 0) {
            this.mpegOffset = this.tokenizer.position - 1;
        }
        return this.tokenizer.readBuffer(buf_frame_header, 1, 3).then(function () {
            var header;
            try {
                header = MpegAudioLayer.FrameHeader.get(buf_frame_header, 0);
            }
            catch (err) {
                _this.warnings.push("Parse error: " + err.message);
                return _this.sync();
            }
            var format = _this.metadata.format;
            // format.dataformat = "MPEG-" + header.version + " Audio Layer " + Util.romanize(header.layer);
            format.dataformat = "mp" + header.layer;
            format.lossless = false;
            format.bitrate = header.bitrate;
            format.sampleRate = header.samplingRate;
            format.numberOfChannels = header.channelMode === "mono" ? 1 : 2;
            if (_this.frameCount < 20 * 10000) {
                debug('offset=%s MP%s bitrate=%s sample-rate=%s', _this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);
            }
            var slot_size = header.calcSlotSize();
            if (slot_size === null) {
                throw new Error("invalid slot_size");
            }
            var samples_per_frame = header.calcSamplesPerFrame();
            var bps = samples_per_frame / 8.0;
            var fsize = (bps * header.bitrate / header.samplingRate) +
                ((header.padding) ? slot_size : 0);
            _this.frame_size = Math.floor(fsize);
            _this.audioFrameHeader = header;
            _this.frameCount++;
            _this.bitrates.push(header.bitrate);
            // xtra header only exists in first frame
            if (_this.frameCount === 1) {
                _this.offset = MpegAudioLayer.FrameHeader.len;
                return _this.skipSideInformation();
            }
            if (_this.frameCount === 3) {
                // the stream is CBR if the first 3 frame bitrates are the same
                if (_this.areAllSame(_this.bitrates)) {
                    // Actual calculation will be done in finalize
                    _this.samplesPerFrame = samples_per_frame;
                    format.codecProfile = "CBR";
                    if (_this.tokenizer.fileSize)
                        return; // Calculate duration based on file size
                }
                else if (!_this.readDuration) {
                    return; // Done
                }
            }
            // once we know the file is VBR attach listener to end of
            // stream so we can do the duration calculation when we
            // have counted all the frames
            if (_this.readDuration && _this.frameCount === 4) {
                _this.samplesPerFrame = samples_per_frame;
                _this.calculateEofDuration = true;
            }
            _this.offset = 4;
            if (header.isProtectedByCRC) {
                return _this.parseCrc();
            }
            else {
                return _this.skipSideInformation();
            }
        });
    };
    MpegParser.prototype.parseCrc = function () {
        var _this = this;
        this.tokenizer.readNumber(Token.INT16_BE).then(function (crc) {
            _this.crc = crc;
        });
        this.offset += 2;
        return this.skipSideInformation();
    };
    MpegParser.prototype.skipSideInformation = function () {
        var _this = this;
        var sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();
        // side information
        return this.tokenizer.readToken(new Token.BufferType(sideinfo_length)).then(function () {
            _this.offset += sideinfo_length;
            return _this.readXtraInfoHeader();
        });
    };
    MpegParser.prototype.readXtraInfoHeader = function () {
        var _this = this;
        return this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag).then(function (headerTag) {
            _this.offset += XingTag_1.InfoTagHeaderTag.len; // 12
            switch (headerTag) {
                case "Info":
                    _this.metadata.format.codecProfile = "CBR";
                    return _this.readXingInfoHeader();
                case "Xing":
                    return _this.readXingInfoHeader().then(function (infoTag) {
                        _this.metadata.format.codecProfile = MpegAudioLayer.getVbrCodecProfile(infoTag.vbrScale);
                        return null;
                    });
                case "Xtra":
                    // ToDo: ???
                    break;
                case "LAME":
                    return _this.tokenizer.readToken(XingTag_1.LameEncoderVersion).then(function (version) {
                        _this.offset += XingTag_1.LameEncoderVersion.len;
                        _this.metadata.format.encoder = "LAME " + version;
                        return _this.skipFrameData(_this.frame_size - _this.offset);
                    });
                // ToDo: ???
            }
            // ToDo: promise duration???
            var frameDataLeft = _this.frame_size - _this.offset;
            if (frameDataLeft < 0) {
                _this.warnings.push("Frame " + _this.frameCount + "corrupt: negative frameDataLeft");
                return _this.sync();
            }
            else {
                return _this.skipFrameData(frameDataLeft);
            }
        });
    };
    /**
     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
     * @returns {Promise<string>}
     */
    MpegParser.prototype.readXingInfoHeader = function () {
        var _this = this;
        return this.tokenizer.readToken(XingTag_1.XingInfoTag).then(function (infoTag) {
            _this.offset += XingTag_1.XingInfoTag.len; // 12
            _this.metadata.format.encoder = Util_1.default.stripNulls(infoTag.encoder);
            if ((infoTag.headerFlags[3] & 0x01) === 1) {
                _this.metadata.format.duration = _this.audioFrameHeader.calcDuration(infoTag.numFrames);
                debug("Get duration from Xing header: %s", _this.metadata.format.duration);
                return infoTag;
            }
            // frames field is not present
            var frameDataLeft = _this.frame_size - _this.offset;
            return _this.skipFrameData(frameDataLeft).then(function () {
                return infoTag;
            });
        });
    };
    MpegParser.prototype.skipFrameData = function (frameDataLeft) {
        var _this = this;
        assert.ok(frameDataLeft >= 0, 'frame-data-left cannot be negative');
        return this.tokenizer.readToken(new Token.IgnoreType(frameDataLeft)).then(function () {
            _this.countSkipFrameData += frameDataLeft;
            return _this.sync();
        });
    };
    MpegParser.prototype.areAllSame = function (array) {
        var first = array[0];
        return array.every(function (element) {
            return element === first;
        });
    };
    return MpegParser;
}(AbstractID3Parser_1.AbstractID3v2Parser));
exports.MpegParser = MpegParser;
