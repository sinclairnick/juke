/// <reference types="node" />
export interface IGetToken<T> {
    /**
     * Length in bytes of encoded value
     */
    len: number;
    /**
     * Decode value from buffer at offset
     * @param buf Buffer to read the decoded value from
     * @param off Decode offset
     */
    get(buf: Buffer, off: number): T;
}
export interface IToken<T> extends IGetToken<T> {
    /**
     * Encode value to buffer
     * @param buffer Buffer to write the encoded value to
     * @param offset Buffer write offset
     * @param value Value to decode of type T
     * @param flush ToDo
     */
    put(buffer: Buffer, offset: number, value: T, flush?: IFlush): number;
}
export declare type IFlush = (b: Buffer, o: number) => void;
/**
 * 8-bit unsigned integer
 */
export declare const UINT8: IToken<number>;
/**
 * 16-bit unsigned integer, Little Endian byte order
 */
export declare const UINT16_LE: IToken<number>;
/**
 * 16-bit unsigned integer, Big Endian byte order
 */
export declare const UINT16_BE: IToken<number>;
/**
 * 24-bit unsigned integer, Little Endian byte order
 */
export declare const UINT24_LE: IToken<number>;
/**
 * 24-bit unsigned integer, Big Endian byte order
 */
export declare const UINT24_BE: IToken<number>;
/**
 * 32-bit unsigned integer, Little Endian byte order
 */
export declare const UINT32_LE: IToken<number>;
/**
 * 32-bit unsigned integer, Big Endian byte order
 */
export declare const UINT32_BE: IToken<number>;
/**
 * 8-bit signed integer
 */
export declare const INT8: IToken<number>;
/**
 * 16-bit signed integer, Big Endian byte order
 */
export declare const INT16_BE: IToken<number>;
/**
 * 16-bit signed integer, Little Endian byte order
 */
export declare const INT16_LE: IToken<number>;
/**
 * 24-bit signed integer, Little Endian byte order
 */
export declare const INT24_LE: IToken<number>;
/**
 * 24-bit signed integer, Big Endian byte order
 */
export declare const INT24_BE: IToken<number>;
/**
 * 32-bit signed integer, Big Endian byte order
 */
export declare const INT32_BE: IToken<number>;
/**
 * 32-bit signed integer, Big Endian byte order
 */
export declare const INT32_LE: IToken<number>;
/**
 * Ignore a given number of bytes
 */
export declare class IgnoreType implements IGetToken<Buffer> {
    len: number;
    /**
     * @param len number of bytes to ignore
     */
    constructor(len: number);
    get(buf: Buffer, off: number): Buffer;
}
export declare class BufferType implements IGetToken<Buffer> {
    len: number;
    constructor(len: number);
    get(buf: Buffer, off: number): Buffer;
}
/**
 * Consume a fixed number of bytes from the stream and return a string with a specified encoding.
 */
export declare class StringType implements IGetToken<string> {
    len: number;
    encoding: string;
    constructor(len: number, encoding: string);
    get(buf: Buffer, off: number): string;
}
/**
 * ANSI Latin 1 String
 * Using windows-1252 / ISO 8859-1 decoding
 */
export declare class AnsiStringType implements IGetToken<string> {
    len: number;
    private static windows1252;
    private static decode(buffer, off, until);
    private static inRange(a, min, max);
    private static codePointToString(cp);
    private static singleByteDecoder(bite);
    constructor(len: number);
    get(buf: Buffer, off?: number): string;
}
