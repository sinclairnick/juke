"use strict";
// A fast streaming parser library.
Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
// Possibly call flush()
var maybeFlush = function (b, o, len, flush) {
    if (o + len > b.length) {
        if (typeof (flush) !== "function") {
            throw new Error("Buffer out of space and no valid flush() function found");
        }
        flush(b, o);
        return 0;
    }
    return o;
};
// Primitive types
/**
 * 8-bit unsigned integer
 */
exports.UINT8 = {
    len: 1,
    get: function (buf, off) {
        return buf.readUInt8(off);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= 0 && v <= 0xff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeUInt8(v, no);
        return (no - o) + this.len;
    }
};
/**
 * 16-bit unsigned integer, Little Endian byte order
 */
exports.UINT16_LE = {
    len: 2,
    get: function (buf, off) {
        return buf.readUInt16LE(off);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= 0 && v <= 0xffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeUInt16LE(v, no);
        return (no - o) + this.len;
    }
};
/**
 * 16-bit unsigned integer, Big Endian byte order
 */
exports.UINT16_BE = {
    len: 2,
    get: function (buf, off) {
        return buf.readUInt16BE(off);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= 0 && v <= 0xffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeUInt16BE(v, no);
        return (no - o) + this.len;
    }
};
/**
 * 24-bit unsigned integer, Little Endian byte order
 */
exports.UINT24_LE = {
    len: 3,
    get: function (buf, off) {
        return buf.readUIntLE(off, 3);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= 0 && v <= 0xffffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeUIntLE(v, no, 3);
        return (no - o) + this.len;
    }
};
/**
 * 24-bit unsigned integer, Big Endian byte order
 */
exports.UINT24_BE = {
    len: 3,
    get: function (buf, off) {
        return buf.readUIntBE(off, 3);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= 0 && v <= 0xffffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeUIntBE(v, no, 3);
        return (no - o) + this.len;
    }
};
/**
 * 32-bit unsigned integer, Little Endian byte order
 */
exports.UINT32_LE = {
    len: 4,
    get: function (buf, off) {
        return buf.readUInt32LE(off);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= 0 && v <= 0xffffffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeUInt32LE(v, no);
        return (no - o) + this.len;
    }
};
/**
 * 32-bit unsigned integer, Big Endian byte order
 */
exports.UINT32_BE = {
    len: 4,
    get: function (buf, off) {
        return buf.readUInt32BE(off);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= 0 && v <= 0xffffffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeUInt32BE(v, no);
        return (no - o) + this.len;
    }
};
/**
 * 8-bit signed integer
 */
exports.INT8 = {
    len: 1,
    get: function (buf, off) {
        return buf.readInt8(off);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= -128 && v <= 127);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeInt8(v, no);
        return (no - o) + this.len;
    }
};
/**
 * 16-bit signed integer, Big Endian byte order
 */
exports.INT16_BE = {
    len: 2,
    get: function (buf, off) {
        return buf.readInt16BE(off);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= -32768 && v <= 32767);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeInt16BE(v, no);
        return (no - o) + this.len;
    }
};
/**
 * 16-bit signed integer, Little Endian byte order
 */
exports.INT16_LE = {
    len: 2,
    get: function (buf, off) {
        return buf.readInt16LE(off);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= -32768 && v <= 32767);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeInt16LE(v, no);
        return (no - o) + this.len;
    }
};
/**
 * 24-bit signed integer, Little Endian byte order
 */
exports.INT24_LE = {
    len: 3,
    get: function (buf, off) {
        return buf.readIntLE(off, 3);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= -0x800000 && v <= 0x7fffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeIntLE(v, no, 3);
        return (no - o) + this.len;
    }
};
/**
 * 24-bit signed integer, Big Endian byte order
 */
exports.INT24_BE = {
    len: 3,
    get: function (buf, off) {
        return buf.readIntBE(off, 3);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= -0x800000 && v <= 0x7fffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeIntBE(v, no, 3);
        return (no - o) + this.len;
    }
};
/**
 * 32-bit signed integer, Big Endian byte order
 */
exports.INT32_BE = {
    len: 4,
    get: function (buf, off) {
        return buf.readInt32BE(off);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= -2147483648 && v <= 2147483647);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeInt32BE(v, no);
        return (no - o) + this.len;
    }
};
/**
 * 32-bit signed integer, Big Endian byte order
 */
exports.INT32_LE = {
    len: 4,
    get: function (buf, off) {
        return buf.readInt32LE(off);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, "number");
        assert.equal(typeof v, "number");
        assert.ok(v >= -2147483648 && v <= 2147483647);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b.writeInt32LE(v, no);
        return (no - o) + this.len;
    }
};
/**
 * Ignore a given number of bytes
 */
var IgnoreType = /** @class */ (function () {
    /**
     * @param len number of bytes to ignore
     */
    function IgnoreType(len) {
        this.len = len;
    }
    // ToDo: don't read, but skip data
    IgnoreType.prototype.get = function (buf, off) {
        return null;
    };
    return IgnoreType;
}());
exports.IgnoreType = IgnoreType;
var BufferType = /** @class */ (function () {
    function BufferType(len) {
        this.len = len;
    }
    BufferType.prototype.get = function (buf, off) {
        return buf.slice(off, off + this.len);
    };
    return BufferType;
}());
exports.BufferType = BufferType;
/**
 * Consume a fixed number of bytes from the stream and return a string with a specified encoding.
 */
var StringType = /** @class */ (function () {
    function StringType(len, encoding) {
        this.len = len;
        this.encoding = encoding;
    }
    StringType.prototype.get = function (buf, off) {
        return buf.toString(this.encoding, off, off + this.len);
    };
    return StringType;
}());
exports.StringType = StringType;
/**
 * ANSI Latin 1 String
 * Using windows-1252 / ISO 8859-1 decoding
 */
var AnsiStringType = /** @class */ (function () {
    function AnsiStringType(len) {
        this.len = len;
    }
    AnsiStringType.decode = function (buffer, off, until) {
        var str = "";
        for (var i = off; i < until; ++i) {
            str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));
        }
        return str;
    };
    AnsiStringType.inRange = function (a, min, max) {
        return min <= a && a <= max;
    };
    AnsiStringType.codePointToString = function (cp) {
        if (cp <= 0xFFFF) {
            return String.fromCharCode(cp);
        }
        else {
            cp -= 0x10000;
            return String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);
        }
    };
    AnsiStringType.singleByteDecoder = function (bite) {
        if (AnsiStringType.inRange(bite, 0x00, 0x7F)) {
            return bite;
        }
        var codePoint = AnsiStringType.windows1252[bite - 0x80];
        if (codePoint === null) {
            throw Error("invaliding encoding");
        }
        return codePoint;
    };
    AnsiStringType.prototype.get = function (buf, off) {
        if (off === void 0) { off = 0; }
        return AnsiStringType.decode(buf, off, off + this.len);
    };
    AnsiStringType.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352,
        8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732,
        8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168,
        169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184,
        185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200,
        201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,
        217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,
        233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,
        248, 249, 250, 251, 252, 253, 254, 255];
    return AnsiStringType;
}());
exports.AnsiStringType = AnsiStringType;
