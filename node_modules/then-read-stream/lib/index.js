"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
var es6_promise_1 = require("es6-promise");
var Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this.promise = new es6_promise_1.Promise(function (resolve, reject) {
            _this.reject = reject;
            _this.resolve = resolve;
        });
    }
    return Deferred;
}());
/**
 * Error message
 */
exports.endOfStream = "End-Of-Stream";
var StreamReader = /** @class */ (function () {
    function StreamReader(s) {
        var _this = this;
        this.s = s;
        this.endOfStream = false;
        /**
         * Store peeked data
         * @type {Array}
         */
        this.peekQueue = [];
        if (!s.read || !s.once) {
            throw new Error("Expected an instance of stream.Readable");
        }
        this.s.once("end", function () {
            _this.endOfStream = true;
            if (_this.request) {
                _this.request.deferred.reject(new Error(exports.endOfStream));
                _this.request = null;
            }
        });
    }
    /**
     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
     * @param buffer Buffer to store data read from stream in
     * @param offset Offset buffer
     * @param length Number of bytes to read
     * @param position Source offset
     * @returns {any}
     */
    StreamReader.prototype.peek = function (buffer, offset, length) {
        var _this = this;
        return this.read(buffer, offset, length).then(function (bytesRead) {
            _this.peekQueue.unshift(buffer.slice(offset, bytesRead));
            return bytesRead;
        });
    };
    /**
     * Read chunk from stream
     * @param buffer Target buffer to store data read from stream in
     * @param offset Offset of target buffer
     * @param length Number of bytes to read
     * @returns {any}
     */
    StreamReader.prototype.read = function (buffer, offset, length) {
        if (length === 0) {
            return es6_promise_1.Promise.resolve(0);
        }
        if (this.peekQueue.length > 0) {
            var peekData_1 = this.peekQueue.shift();
            if (length <= peekData_1.length) {
                peekData_1.copy(buffer, offset, 0, length);
                if (length < peekData_1.length) {
                    this.peekQueue.unshift(peekData_1.slice(length));
                }
                return es6_promise_1.Promise.resolve(length);
            }
            else {
                peekData_1.copy(buffer, offset);
                return this.read(buffer, offset + peekData_1.length, length - peekData_1.length).then(function (bytesRead) {
                    return peekData_1.length + bytesRead;
                }).catch(function (err) {
                    if (err.message === exports.endOfStream) {
                        return peekData_1.length; // Return partial read
                    }
                    else
                        throw err;
                });
            }
        }
        else {
            return this._read(buffer, offset, length);
        }
    };
    /**
     * Read chunk from stream
     * @param buffer Buffer to store data read from stream in
     * @param offset Offset buffer
     * @param length Number of bytes to read
     * @returns {any}
     */
    StreamReader.prototype._read = function (buffer, offset, length) {
        var _this = this;
        assert.ok(!this.request, "Concurrent read operation?");
        if (this.endOfStream) {
            return es6_promise_1.Promise.reject(new Error(exports.endOfStream));
        }
        var readBuffer = this.s.read(length);
        if (readBuffer) {
            readBuffer.copy(buffer, offset);
            return es6_promise_1.Promise.resolve(readBuffer.length);
        }
        else {
            this.request = {
                buffer: buffer,
                offset: offset,
                length: length,
                deferred: new Deferred()
            };
            this.s.once("readable", function () {
                _this.tryRead();
            });
            return this.request.deferred.promise.then(function (n) {
                _this.request = null;
                return n;
            }).catch(function (err) {
                _this.request = null;
                throw err;
            });
        }
    };
    StreamReader.prototype.tryRead = function () {
        var _this = this;
        var readBuffer = this.s.read(this.request.length);
        if (readBuffer) {
            readBuffer.copy(this.request.buffer, this.request.offset);
            this.request.deferred.resolve(readBuffer.length);
        }
        else {
            this.s.once("readable", function () {
                _this.tryRead();
            });
        }
    };
    return StreamReader;
}());
exports.StreamReader = StreamReader;
